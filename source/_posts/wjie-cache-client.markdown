---
title: 客户端 iOS Android 缓存优化
date: 2016-07-29 10:12:15
tags: 缓存优化 设计
---

# 前言

每个应用为了不同的目的或多或少都需要缓存一些服务端上的数据。缓存数据看似简单又让人感觉头疼。在前期开发的时候往往不注重对缓存的设计导致程序越写越乱，越设计越越乱。往往都是事倍工半，偶尔升级版本数据格式发生变化导致应用崩溃，错误莫名奇妙的。这里我主要介绍是对大数据量缓存的优化与设计。 

##优化目标

	* app在使用缓存的时候用复杂逻辑判断缓存是否存在。
	* 去掉某些界面显示缓存数据显示数据加载中等默认的界面。
	* 更新缓存数据时由于网络原因导致接到数据不全从而应用出现未知问题。
	* 由于迭代版本时出现的一些问题。
	* 等等其他原因。

<!-- more -->

##优化的流程

![缓存设计](/images/article/wjie-cache/客户端缓存优化.png)

**1.首先要确认我们需要哪些缓存**

例如：省市县区乡，这些不经常发生变化的关系型数据或者是’搜索关键字‘这一类型频繁更新的非关系型数据。针对不同的数据，当然我们可以选择不同的策略。

或用sqlite文件存储 或用json 格式的文件，或用xml格式的文件等等其他格式的文件存储,都是你的选择。

这里我建议根据不同类型数据用不同策略处理。对于省市县区乡这一类型的数据我建议用sqlite文件，原因是如果你采用json 、xml 、或者二进制，势必要把整个文件读取出来，这样对于电量有限，cpu有限，内存有限的移动平台势必有一个加载数据解析数据的过程造成对用户的体验上问题。如果你对一些非关系型数据采用sqlite 这样关系型数据库存储，可能提高你对数据处理的复杂性逻辑。**确定好策略设计好数据格式**使我们第一步主要做的事情，我们第一步会对我们的app有很深远的影响。

**2.打包|编译应用对于缓存我们需要做什么**

选择好策略设计好数据格式之后 这里我采用sqlite db 缓存 省市县区乡 以下我采用的例子都是简称db。 

**服务端向我们提供1**这样格式的文件。并提供出该文件的version（以下简称version）和文件的MD5值（以下简称MD5）。我们把这些**编译或打包到程序当中**。

**服务端向我们提供2**该文件最新的new md5、new version、new db文件下载地址的接口。

**3.安装应用之后 启动应用我们需要怎么做**

在启动应用显示launch界面过程中开启一个新线程A（以下简称A）。

>在A中我们检查本App 的cache目录db、MD5、version是否存在：

> > **存在**，则判断new db、new MD5、new version 是否存在：
> > 
> > > **存在**，判断new version 是否大于 已经缓存的old version
> > > 
> > > > **大于** 用新的new db，new md5、new version 覆盖已经存在cache目录当中文件，然后删除 new db，new md5、new version 然后判断程序中的version 大于 cache中的version
> > > > 
> > > > > **大于** 从程序中拷贝db和md5，version到cache目录进行替换。结束线程A
> > > > > 
> > > > > **不大于** 结束线程A
> > > > 
> > > > **不大于** 删除 new db、new md5、new version，然后判断程序中的version 大于 cache中的version
> > > > 
> > > > > **大于** 从程序中拷贝db和md5，version到cache目录进行替换。结束线程A
> > > > > 
> > > > > **不大于** 结束线程A
> > > 
> > > **不存在**，判断程序中的version 大于 cache中的version
> > > 
> > > > **大于** 从程序中拷贝db和md5，version到cache目录进行替换。结束线程A
> > > > 
> > > > **不大于** 结束线程A
> > 
> > **不存在**,从程序中拷贝db和md5，version到cache目录。结束线程A

结束新线程A之后显示引导页或者 主界面 等等。

**4.我们需要在什么时候向服务器询问是否和怎么更新**

由于我选择是省市县区乡 不经常发生变化的关系型大量数据。我可以选择在程序在空闲并且有WIFI的情况下，我开启新线程B。向服务器发起请求，服务器返回最新的new db 下载路径，new md5、new version。

> 用new version 与本地cache目录version比较，如果new version > cache 中version
> 
> > **大于** ， 用new db 下载路径从服务器下载到本地cache目录中（注意名字不要和本地缓存的db文件名一样）校验new db ，得到new db 的md5 与new md5比较是否相等
> > 
> > > **相等** ，把文件重命名为new db，
把new md5，new version 存到本地当中。等待下次启动替换旧文件，结束线程B。
> > > 
> > > **不相等**，删除new db 结束线程B。
> > 
> > **不大于**，结束线程B。
> > 
结束线程B了不做任何操作。等待下次启动。
























